{% macro forAllParameters type %}x: {% ifnot type|annotated:"swiftCheckTypeOf"%}{% ifnot type|annotated:"arrowOf"%}String{% else %}ArrowOf<String,String>{% endif %}{% else %}{{ type.name }}Of<String>{% endif %}{% if type|annotated:"needContext" %}, context: String{% endif %}{% if type|annotated:"stringContext"%}, context: String{% endif %}{% if type|annotated:"center"%}, y: String{% endif%}{% if type|annotated:"product"%}, y: String{% endif%}{% endmacro %}

{% macro generalValueOfType type %}{% if not type|annotated:"swiftCheckTypeOf"%}{% if not type|annotated:"arrowOf" %}{% if not type|annotated:"result" %}{% if not type|annotated:"state" %}{{ type.name }}.unfold({ $0(x) }){% else %}State<String,String>.unfold{ s in (s,x)}{% endif %}{% else %}Result<AnyError,String>.success(x){% endif %}{% else %}{{ type.name }}{% if type|annotated:"needUnfold"%}.unfold{% else %}.init{% endif %}(x.getArrow){% endif %}{% else %}x.get{{ type.name }}{% endif %}{% endmacro %}

{% macro valueOfType type %}{% if type|annotated:"writer"%}Writer<String,String>.init(log: context, value: x){% else %}{% call generalValueOfType type %}{% endif %}{% endmacro %}

{% macro equal type %}{% call valueOfType type %}.map(fidentity) == fidentity({% call valueOfType type %}){% endmacro %}

{% macro identitySideFor type side %}
// {{ side|capitalize }} Identity Law
    func test{{ type.name }}{{ side|capitalize }}Identity() {
        property("{{ type.name }} - Functor Laws - {{ side|capitalize }} Identity") <- forAll { ({% call forAllParameters type %}) in
            return {{ type.name }}<String,String>.{{ side }}(x).map{{ side|capitalize }}(fidentity) == fidentity({{ type.name }}<String,String>.{{ side }}(x))
        }
    }
{% endmacro %}

{% macro productMapFor position %}{% if position|contains:"both" %}bimap(onFirst: fidentity, onSecond: fidentity){% else %}map{{ position|capitalize }}(fidentity){% endif %}{% endmacro %}

{% macro identityProduct position %}
// {{ position|capitalize }} Identity Law
    func test{{ type.name }}{{ position|capitalize }}Identity() {
        property("{{ type.name }} - Functor Laws - {{ position|capitalize }} Identity") <- forAll { ({% call forAllParameters type %}) in
            return {{ type.name }}<String,String>.init(x,y).{% call productMapFor position %} == fidentity({{ type.name }}<String,String>.init(x,y))
        }
    }
{% endmacro %}

import XCTest
@testable import FunctionalKit
import SwiftCheck
import Abstract

class FunctorLawsTests: XCTestCase {

{% for type in types.all|annotated:"functor" %}

//MARK: {{ type.name }}

{% if type|annotated:"simpleMap" %}
// Identity Law
    func test{{ type.name }}Identity() {
        property("{{ type.name }} - Functor Laws - Identity") <- forAll { ({% call forAllParameters type %}) in
            return {% if type|annotated:"needContext"%}({% call equal type %}).run(context){% else %}{% call equal type %}{% endif %}
        }
    }

{% endif %}

{% if type|annotated:"left" %}{% call identitySideFor type "left" %}{% endif %}

{% if type|annotated:"right" %}{% call identitySideFor type "right" %}{% endif %}

{% if type|annotated:"center" %}
    func test{{ type.name }}CenterIdentity() {
        property("{{ type.name }} - Functor Laws - Center Identity") <- forAll { ({% call forAllParameters type %}) in
            return {{ type.name }}<String,String>.center(x,y).bimap(onLeft: fidentity, onRight: fidentity) == fidentity({{ type.name }}<String,String>.center(x,y))
        }
    }
{% endif %}

{% if type|annotated:"product" %}
{% call identityProduct "first" %}

{% call identityProduct "second" %}

{% call identityProduct "both" %}
{% endif %}

{% endfor %}
}
