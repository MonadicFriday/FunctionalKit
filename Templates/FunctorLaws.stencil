{% macro forAllParameters type %}(x: {% ifnot type|annotated:"swiftCheckTypeOf"%}{% ifnot type|annotated:"arrowOf"%}Int{% else %}ArrowOf<Int,Int>{% endif %}{% else %}{{ type.name }}Of<Int>{% endif %}{% if type|annotated:"needContext" %}, context: {% if type|annotated:"errorContext"%}AnyError{% else %}Int{% endif %}{% endif %}{% if type|annotated:"center"%}, y: Int{% endif%}{% if type|annotated:"product"%}, y: Int{% endif%}){% endmacro %}

{% macro valueOfType type %}{% if not type|annotated:"swiftCheckTypeOf"%}{% if not type|annotated:"arrowOf" %}{% if not type|annotated:"result" %}{{ type.name }}.unfold({ $0(x) }){% else %}Result<AnyError,Int>.success(x){% endif %}{% else %}{{ type.name }}{% if type|annotated:"needUnfold"%}.unfold{% else %}.init{% endif %}(x.getArrow){% endif %}{% else %}x.get{{ type.name }}{% endif %}{% endmacro %}

{% macro equal type %}{% call valueOfType type %}.map(fidentity) == fidentity({% call valueOfType type %}){% endmacro %}

{% macro identitySideFor type side %}
// {{ side|capitalize }} Identity Law
    func test{{ type.name }}{{ side|capitalize }}Identity() {
        property("{{ type.name }} - Functor Laws - {{ side|capitalize }} Identity") <- forAll { {% call forAllParameters type %} in
            return {{ type.name }}<Int,Int>.{{ side }}(x).map{{ side|capitalize }}(fidentity) == fidentity({{ type.name }}<Int,Int>.{{ side }}(x))
        }
    }
{% endmacro %}

{% macro productMapFor position %}{% if position|contains:"both" %}bimap(onFirst: fidentity, onSecond: fidentity){% else %}map{{ position|capitalize }}(fidentity){% endif %}{% endmacro %}

{% macro identityProduct position %}
// {{ position|capitalize }} Identity Law
    func test{{ type.name }}{{ position|capitalize }}Identity() {
        property("{{ type.name }} - Functor Laws - {{ position|capitalize }} Identity") <- forAll { {% call forAllParameters type %} in
            return {{ type.name }}<Int,Int>.init(x,y).{% call productMapFor position %} == fidentity({{ type.name }}<Int,Int>.init(x,y))
        }
    }
{% endmacro %}

import XCTest
@testable import FunctionalKit
import SwiftCheck

class FunctorLawsTests: XCTestCase {

{% for type in types.all|annotated:"functor" %}

//MARK: {{ type.name }}

{% if type|annotated:"simpleMap" %}
// Identity Law
    func test{{ type.name }}Identity() {
        property("{{ type.name }} - Functor Laws - Identity") <- forAll { {% call forAllParameters type %} in
            return {% if type|annotated:"needContext"%}({% call equal type %}).run(context){% else %}{% call equal type %}{% endif %}
        }
    }
{% endif %}

{% if type|annotated:"left" %}{% call identitySideFor type "left" %}{% endif %}

{% if type|annotated:"right" %}{% call identitySideFor type "right" %}{% endif %}

{% if type|annotated:"center" %}
    func test{{ type.name }}CenterIdentity() {
        property("{{ type.name }} - Functor Laws - Center Identity") <- forAll { {% call forAllParameters type %} in
            return {{ type.name }}<Int,Int>.center(x,y).bimap(onLeft: fidentity, onRight: fidentity) == fidentity({{ type.name }}<Int,Int>.center(x,y))
        }
    }
{% endif %}

{% if type|annotated:"product" %}
{% call identityProduct "first" %}

{% call identityProduct "second" %}

{% call identityProduct "both" %}
{% endif %}

{% endfor %}
}
