{# GLOBAL MACROS #}
{% macro getTypeName type parameter %}{{ type.name }}<{% if type|annotated:"needsSecondary" %}String,{% endif %}{{ parameter }}>{% endmacro %}
{% macro getMapName type %}{% if type|annotated:"customMap" %}{{ type.annotations.customMap }}{% else %}map{% endif %}{% endmacro %}
{% macro getCommandCall type %}{% if type|annotated:"needsCommand" %}.{{ type.annotations.needsCommand }}{% endif %}{% endmacro %}
{% macro getContextCall type %}{% if type|annotated:"needsContext" %}.run(c){% endif %}{% endmacro %}
{% macro getContextParam type %}{% if type|annotated:"needsContext" %}, c: String{% endif %}{% endmacro %}

{# FUNCTOR MACROS #}
{% macro functorLaws type %}
    func test{{ type.name }}FunctorIdentity() {
        property("{{ type.name }} - Functor Laws - Identity") <- forAll { (x: String{% call getContextParam type %}) in
            let a = {% call getTypeName type "String" %}.{{ type.annotations.construct }}
            return (a.map(fidentity){% call getCommandCall type %} == a{% call getCommandCall type %}){% call getContextCall type %}
        }
    }

    func test{{ type.name }}FunctorComposition() {
        property("{{ type.name }} - Functor Laws - Identity") <- forAll { (f: ArrowOf<String,String>, g: ArrowOf<String,String>, x: String{% call getContextParam type %}) in
            let a = {% call getTypeName type "String" %}.{{ type.annotations.construct }}
            let fLifted = fflip({% call getTypeName type "String" %}.{% call getMapName type %})(f.getArrow)
            let gLifted = fflip({% call getTypeName type "String" %}.{% call getMapName type %})(g.getArrow)
            return ((fLifted..gLifted)(a){% call getCommandCall type %} == a.{% call getMapName type %}(f.getArrow..g.getArrow){% call getCommandCall type %}){% call getContextCall type %}
        }
    }

{% endmacro %}

{# APPLICATIVE MACROS #}
{% macro applicativeLaws type %}
    func test{{ type.name }}ApplicativeIdentity() {
        property("{{ type.name }} - Applicative Laws - Identity") <- forAll { (x: String{% if type|annotated:"needsContext" %}, c: String{% endif%}) in
            let a_a = {% call getTypeName type "Endo<String>" %}.pure(fidentity)
            let a = {% call getTypeName type "String" %}.pure(x)
            return ((a_a <*> a){% call getCommandCall type %} == a{% call getCommandCall type %}){% call getContextCall type %}
        }
    }

    func test{{ type.name }}ApplicativeHomomorphism() {
        property("{{ type.name }} - Applicative Laws - Homomorphism") <- forAll { (af: ArrowOf<String,String>, x: String{% if type|annotated:"needsContext" %}, c: String{% endif%}) in
            let a_a = {% call getTypeName type "Endo<String>" %}.pure(af.getArrow)
            let a1 = {% call getTypeName type "String" %}.pure(x)
            let a2 = {% call getTypeName type "String" %}.pure(af.getArrow(x))
            return ((a_a <*> a1){% call getCommandCall type %} == a2{% call getCommandCall type %}){% call getContextCall type %}
        }
    }
{% endmacro %}

{# IMPLEMENTATION #}
import XCTest
@testable import FunctionalKit
import SwiftCheck
import Abstract

class LawsTests: XCTestCase {
{% for type in types.all|annotated:"functor" %}

//MARK: {{ type.name }}
{% if type|annotated:"functor" %}{% call functorLaws type %}{% endif %}
{% if type|annotated:"applicative" %}{% call applicativeLaws type %}{% endif %}

{% endfor %}

}
